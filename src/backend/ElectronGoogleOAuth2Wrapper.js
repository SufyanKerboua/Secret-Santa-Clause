"use strict";

const electron_1 = require("electron");
const events_1 = require("events");
const google_auth_library_1 = require("google-auth-library");
const querystring_1 = require("querystring");
const url = require("url");

const LoopbackRedirectServer_1 = require("./LoopbackRedirectServer");
const BW = process.type === 'renderer' ? electron_1.remote.BrowserWindow : electron_1.BrowserWindow;

let defaultElectronGoogleOAuth2WrapperOptions = {
    successRedirectURL: 'https://getstation.com/app-login-success/',
    loopbackInterfaceRedirectionPort: 42813,
    refocusAfterSuccess: true,
};

class ElectronGoogleOAuth2Wrapper extends events_1.EventEmitter  {
    constructor(clientId, clientSecret, scopes, options = defaultElectronGoogleOAuth2WrapperOptions) {
        super();
        // Force fetching id_token if not provided
        if (!scopes.includes('profile'))
            scopes.push('profile');
        if (!scopes.includes('email'))
            scopes.push('email');
        this.scopes = scopes;
        this.clientId = clientId;
        this.clientSecret = clientSecret;
        this.options = Object.assign(Object.assign({}, defaultElectronGoogleOAuth2WrapperOptions), options);
        this.oauth2Client = new google_auth_library_1.OAuth2Client(clientId, clientSecret, `http://127.0.0.1:${this.options.loopbackInterfaceRedirectionPort}/callback`);
        this.oauth2Client.on('tokens', (tokens) => {
            this.emit('tokens', tokens);
        });
        this.server;
    }
    /**
     * Returns authUrl generated by googleapis
     * @param {boolean} forceAddSession
     * @returns {string}
     */
    generateAuthUrl(forceAddSession = false) {
        let url = this.oauth2Client.generateAuthUrl({
            access_type: 'offline',
            scope: this.scopes,
            redirect_uri: `http://127.0.0.1:${this.options.loopbackInterfaceRedirectionPort}/callback`
        });
        if (forceAddSession) {
            const qs = querystring_1.stringify({ continue: url });
            url = `https://accounts.google.com/AddSession?${qs}`;
        }
        return url;
    }
    /**
     * Get authorization code for underlying authUrl
     * @param {boolean} forceAddSession
     * @returns {Promise<string>}
     */
    getAuthorizationCode(forceAddSession = false) {
        const url = this.generateAuthUrl(forceAddSession);
        return this.openAuthWindowAndGetAuthorizationCode(url);
    }
    /**
     * Get authorization code for given url
     * @param {string} urlParam
     * @returns {Promise<string>}
     */
    openAuthWindowAndGetAuthorizationCode(urlParam) {
        return this.openAuthPageAndGetAuthorizationCode(urlParam);
    }
    
    async openAuthPageAndGetAuthorizationCode(urlParam) {
        // return __awaiter(this, void 0, void 0, function* () {
            if (this.server) {
                // if a server is already running, we close it so that we free the port
                // and restart the process
                await this.server.close();
                this.server = null;
            }
            this.server = new LoopbackRedirectServer_1.default({
                port: this.options.loopbackInterfaceRedirectionPort,
                callbackPath: '/callback',
                successRedirectURL: this.options.successRedirectURL,
            });
            // shell.openExternal(urlParam);
            let win2 = new electron_1.BrowserWindow({ width: 500, height: 600 });
            win2.loadURL(urlParam, { userAgent: 'Chrome' });
            win2.webContents;
            // console.log(contents);
            const reachedCallbackURL = await this.server.waitForRedirection();
            // waitForRedirection will close the server
            this.server = null;
            win2.close();
            const parsed = url.parse(reachedCallbackURL, true);
            if (parsed.query.error) {
                throw new Error(parsed.query.error_description);
            }
            else if (!parsed.query.code) {
                throw new Error('Unknown');
            }
            if (this.options.refocusAfterSuccess) {
                // refocus on the window
                BW.getAllWindows().filter(w => w.isVisible()).forEach(w => w.show());
            }
            return parsed.query.code;
        // });
    }
    /**
     * Get Google tokens for given scopes
     * @param {boolean} forceAddSession
     * @returns {Promise<Credentials>}
     */
    async openAuthWindowAndGetTokens(forceAddSession = false) {
        return this
            .getAuthorizationCode(forceAddSession)
            .then((authorizationCode) => {
            return this.oauth2Client
                .getToken(authorizationCode)
                .then(response => {
                this.oauth2Client.setCredentials(response.tokens);
                console.log("In OauthGoogle my token :", response.tokens);
                return response.tokens;
            });
        });
    }
    /**
     * Get Google settings requiered to send mails for given scopes
     * @param {string} lastRefreshToken
     * @param {boolean} forceAddSession
     * @returns {clientSecret: string, refreshToken: string, accessToken: string, expires: integer}
     */
    async openAuthWindowAndGetTokensGmail(lastRefreshToken, forceAddSession = false) {
        return this
            .getAuthorizationCode(forceAddSession)
            .then((authorizationCode) => {
            return this.oauth2Client
                .getToken(authorizationCode)
                .then(async (response) => {
                    console.log("All response : ", response);
                    this.oauth2Client.setCredentials(response.tokens);
                    if (response.tokens.refresh_token == undefined) {
                        console.log("Refresh Token Changed");
                        response.tokens.refresh_token = lastRefreshToken;
                    }
                    return {
                        clientId: this.clientId,
                        clientSecret: this.clientSecret,
                        refreshToken: response.tokens.refresh_token,
                        accessToken: response.tokens.access_token,
                        expires: response.tokens.expiry_date
                    };
            });
        });
    }
    setTokens(tokens) {
        this.oauth2Client.setCredentials(tokens);
    }
}

module.exports = ElectronGoogleOAuth2Wrapper;